# Go

- 本内容主要来自于[Go语言圣经](https://books.studygolang.com/gopl-zh/ch2/ch2-02.html)

## Go 初识

- 编译型语言
- 支持高并发

## 基本命令

- go run 运行一个项目
- go build 在不同的系统生成不同后缀的可执行文件，之后可以随时运行


## Go代码格式

```golang
package main

import "fmt"

func main() {
    fmt.Println("Hello, world")
}
```
- Go语言的代码通过包（package）组织，包类似于其它语言里的库（libraries）或者模块（modules）。
- 每个源文件都以一条package声明语句开始
- main包比较特殊。它定义了一个独立可执行的程序，而不是一个库
- 在main里的main 函数也很特殊，它是整个程序执行时的入口,main函数所做的事情就是程序做的。
- import 指定需要哪些包
- import声明必须跟在文件的package声明之后
- import 导入的包必须使用，如果不使用，不能通过编译

- Go语言在代码格式上采取很强硬的态度，gofmt 工具可以把代码格式化为标准格式
- goimports 工具可以根据代码需要，自动地添加或者删除import声明
- 安装命令 go get golang.org/x/tools/cmd/goimports

## Go语法

### 命名
- 区分大小写
- 一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线
- 驼峰式命名
- Go语言的风格是尽量使用短小的名字，对于局部变量尤其是这样

### 声明

- Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。

- 一个函数的声明由一个函数名字、参数列表（由函数的调用者提供参数变量的具体值）、一个可选的返回值列表和包含函数定义的函数体组成。


```golang
func fToC(f float64) float64 {
    return (f - 32) * 5 / 9
}


```

### 变量
#### 变量一般声明语法
- var 变量名字 类型 = 表达式
- 其中“类型”或“= 表达式”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。
- 数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil。

#### 简短变量声明
- 名字 := 表达式

- 简短变量声明被广泛用于大部分的局部变量的声明和初始化。var形式的声明语句往往是用于需要显式指定变量类型地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方

- 简短变量声明语句中必须至少要声明一个新的变量

#### 指针

- 一个变量对应一个保存了变量对应类型值的内存空间。

```golang
/*
如果用“var x int”声明语句声明一个x变量，那么&x表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是*int，指针被称之为“指向int类型的指针”。如果指针名字为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”。同时*p表达式对应p指针指向的变量的值。一般*p表达式读取指针指向的变量的值，这里为int类型的值，同时因为*p对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。
*/
x := 1
p := &x         // p, of type *int, points to x
fmt.Println(*p) // "1"
*p = 2          // equivalent to x = 2
fmt.Println(x)  // "2"
```
- 任何类型的指针的零值都是nil。如果p指向某个有效变量，那么p != nil测试为真。指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。

```Golang
package main 

import (
	"flag"
	"fmt"
	"strings"
)

var n = flag.Bool("n", false, "omit  trailing newline")
// 调用flag.Bool函数会创建一个新的对应布尔型标志参数的变量。它有三个属性：第一个是的命令行标志参数的名字“n”，然后是该标志参数的默认值（这里是false），最后是该标志参数对应的描述信息。
var sep = flag.String("s", " ", "separator")
//sep和n变量分别是指向对应命令行标志参数变量的指针
//因此必须用*sep和*n形式的指针语法间接引用它们

func main() {
	flag.Parse()
	fmt.Print(strings.Join(flag.Args(), *sep))
	if !*n {
		fmt.Println()
	}
}


```

#### new函数

- 表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址

```golang
p := new(int)   // p, *int 类型, 指向匿名的 int 变量
fmt.Println(*p) // "0"
*p = 2          // 设置 int 匿名变量的值为 2
fmt.Println(*p) // "2"
```
- 用new创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外，我们还可以在表达式中使用new(T)。

#### 变量的生命周期

- 变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。

- 对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。而相比之下，局部变量的声明周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收


```golang
var global *int

func f() {
    var x int
    x = 1
    global = &x
}

```

- 如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）