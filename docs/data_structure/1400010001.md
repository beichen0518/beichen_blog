
# 数据结构

## 线性表

### 线性表顺序存储结构

- 存，取 时间复杂度O(1)

- 插入，删除 时间复杂度O(n)

#### 优点

- 无须为表示表中元素之间的逻辑关系而增加额外的存储空间

- 可以快速地存取表中任一位置的元素

#### 缺点

- 插入和删除操作需要移动大量元素
- 当线性表长度变化较大时，难以确定存储空间的容量
- 造成存储空间的“碎片”

### 单链表

- 存，取，插入，删除 时间复杂度O(n)

- 如何在一个位置插入多条数据，那么之后的数据时间复杂度为O(1)

- 对于插入或删除数据越频繁的操作，单链表的效率优势就越是明显


### 循环链表

- 将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。

### 双向链表

- 双向链表是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。

## 栈和队列

### 栈

- 限定仅在表尾进行插入和删除操作的线性表

## 树

- 树（tree）是n>=0个结点的有限集，n=0时称为空树，在任意一棵非空树中，有且仅有一个称为根的结点，
当n>1时，其余结点可以分为m（m>0）个互不相交的有限集T1，T2...Tm,其中每一个集合本身又是一颗树，并且称为根的子树（SUbtree）。

- 结点拥有的子树数称为结点的度（Degree），度为0的结点称为叶结点(Leaf)或终端结点，度不为0的结点称为非终端结点或分支结点，除根结点外，分支结点也称为内部结点。树的度是树内各结点的最大值。

### 二叉树的遍历

- 前序遍历
```Python

def pre_order_traverse(tree_point):
	if tree_point == None:
		return
	print(tree_point)
	pre_order_traverse(left_point)
	pre_order_traverse(right_point)

```

- 中序遍历

```Python

def in_order_traverse(tree_point):
	if tree_point == None:
		return
	print(tree_point)
	in_order_traverse(left_point)
	in_order_traverse(right_point)

```

- 后序遍历

```Python
def post_order_traverse(tree_point):
	if tree_point == None:
		return	
	post_order_traverse(left_point)
	post_order_traverse(right_point)
	print(tree_point)

```

- 已知前序遍历和中序遍历可以唯一确定一棵二叉树
- 已知后序遍历和中序遍历可以唯一确定一棵二叉树

### 树和森林

- 当以二叉链表作树的存储结构时，树的先根遍历和后根遍历完全可以借用二叉树的前序遍历和中序遍历的算法来实现

#### 赫夫曼树

- 对于有带权值的二茬树的结点的集合，以左边小右边大的顺序，从集合选出权值最小的两个结点，组合成新的树，新树根结点的权值为两结点之和，将新结点重新加入集合，重复此步骤，最后构成的树就是赫夫曼树

## 图

- 图（Graph）是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为G（V,E）,其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。

### 图的存储方式

#### 邻接矩阵

- 图的邻接矩阵存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。

- 邻接表
- 将数组与链表相结合的存储方法称为邻接表
